# 第 06 章_索引的数据结构

 讲师：尚硅谷-宋红康（江湖人称：康师傅）

官网： **[http://www.atguigu.com](http://www.atguigu.com)**

## 1. 为什么使用索引

 假如给数据使用二叉树这样的数据结构进行存储，如下图所示
![img.png](img.png)

如上图所示，数据库没有索引的情况下，数据`分布在硬盘不同的位置上面`，读取数据时，摆臂需要前后摆动查找数
据，这样操作非常消耗时间。如果`数据顺序摆放`，那么也需要从1到6行按顺序读取，这样就相当于进行了6次1O操
作，`依旧非常耗时`。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Cl2=89这条记录，就
要逐行去查找、去比较。从Col2=34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数
据，但如果表很大的话，`有上千万条数据`，就意味着要做很多很多次磁盘I/0才能找到。现在要查找Col2=89这
条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是
磁盘I/O (涉及到磁盘的旋转时间（速度较快）、磁头的寻道时间(速度慢、费时)）

对字段Col2添加了索引，就相当于在硬盘上为Cl2维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索
树的每个结点存储的是(K,V)结构，key是col2,value是该key所在行的文件指针（地址）。比如：该二叉搜
索树的根节点就是：(34,8x07)。现在对Col2添加了索引，这时再去查找Co2=89这条记录的时候会先去查
找该二叉搜索树（二叉树的遍历查找）。读34到内存，89>34；继续右侧数据，读89到内存，89=89；找到数
据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次
就可以定位到记录的地址，查询速度就提高了。
这就是我们为什么要建索引，目的就是为了减少磁盘I/0的次数，加快查询速率。
## 2. 索引及其优缺点


### 2. 1 索引概述

MySQL官方对索引的定义为： **索引（Index）是帮助MySQL高效获取数据的数据结构** 。

**索引的本质：** 索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。
这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法。

### 2. 2 索引的优点

1. 类似大学图书馆建书目索引，**提高数据检索的效率，降低数据库的IO成本**，这也是创建索引最主要的原因。
2. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 
3. 在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 
4. 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。

### 2. 3 缺点

 增加索引也有许多不利的方面，主要表现在如下几个方面： 
1. 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。 
2. 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文
件更快达到最大文件尺寸。 
3. 虽然索引大大提高了查询速度，同时却会**降低更新表的速度**。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，
这样就降低了数据的维护速度。因此，选择使用索引时，需要综合考虑索引的优点和缺点。

## 3. InnoDB中索引的推演(忽略)

### 3. 1 索引之前的查找

 先来看一个精确匹配的例子：
```
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

#### 1. 在一个页中的查找
假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同
分为两种情况：

- 以主键为搜索条件
可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
- 以其他列作为搜索条件
因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，
然后对比每条记录是不是符合搜索条件。很显然， 这种查找的效率是非常低的。

#### 2. 在很多页中查找

大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话
可以分为两个步骤：
1. 定位到记录所在的页。
2. 从所在的页内中查找相应的记录。

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，
所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，
所以这种方式显然是超级耗时的。如果一个表有一亿条记录呢？此时索引应运而生。



### 3. 2 设计索引

 建一个表：
```
mysql> CREATE TABLE index_demo(
-> c1 INT,
-> c2 INT,
-> c3 CHAR(1),
-> PRIMARY KEY(c1)
-> ) ROW_FORMAT = Compact;
```
这个新建的index_demo表中有 2 个INT类型的列， 1 个CHAR(1)类型的列，而且我们规定了c1列为主键，
这个表使用Compact行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：

 我们只在示意图里展示记录的这几个部分：
![img_1.png](img_1.png)

- `record_type`：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记

- `next_record`：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。
- `各个列的值`：这里只记录在index_demo表中的三个列，分别是c1、c2和c3。
- `其他信息`：除了上述 3 种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：

 把一些记录放到页里的示意图就是：


#### 1. 一个简单的索引设计方案

 我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规

 律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果

 我们想快速的定位到需要查找的记录在哪些数据页中该咋办？我们可以为快速定位记录所在的数据页而建

 立一个目录，建这个目录必须完成下边这些事：

 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。

 给所有的页建立一个目录项。

 所以我们为上边几个页做好的目录就像这样子：

 以页 28 为例，它对应目录项 2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主

 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键

 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：

 1. 先从目录项中根据二分法快速确定出主键值为 20 的记录在目录项 3 中（因为 12 < 20 <

 209 ），它对应的页是页 9 。

 2. 再根据前边说的在页中查找记录的方式去页 9 中定位具体的记录。

 至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为索引。

#### 2. InnoDB中的索引方案

 ① 迭代 1 次：目录项纪录的页

 我们把前边使用到的目录项放到数据页中的样子就是这样：


 从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储目录项记录。这里再次强调目录项记录

 和普通的用户记录的 不同点 ：

```
目录项记录的record_type值是 1 ，而普通用户记录的record_type值是 0 。
目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很
多列，另外还有InnoDB自己添加的隐藏列。
了解：记录头信息里还有一个叫min_rec_mask的属性，只有在存储目录项记录的页中的主键值
最小的目录项记录的min_rec_mask值为 1 ，其他别的记录的min_rec_mask值都是 0 。
```
**相同点：** 两者用的是一样的数据页，都会为主键值生成Page Directory（页目录），从而在按照主键
值进行查找时可以使用二分法来加快查询速度。

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

```
1. 先到存储目录项记录的页，也就是页 30 中通过二分法快速定位到对应目录项，因为12 < 20 <
209 ，所以定位到对应的记录所在的页就是页 9 。
2. 再到存储用户记录的页 9 中根据二分法快速定位到主键值为 20 的用户记录。
```
**② 迭代 2 次：多个目录项纪录的页**

 从图中可以看出，我们插入了一条主键值为 320 的用户记录之后需要两个新的数据页：

 为存储该用户记录而新生成了页 31 。

 因为原先存储目录项记录的页 30 的容量已满（我们前边假设只能存储 4 条目录项记录），所以不得

 不需要一个新的页 32 来存放页 31 对应的目录项。

 现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要 3 个步

 骤，以查找主键值为 20 的记录为例：

 1. 确定目录项记录页

 我们现在的存储目录项记录的页有两个，即页 30 和页 32 ，又因为页 30 表示的目录项的主键值的

 范围是[1, 320)，页 32 表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目

 录项记录在页 30 中。

 2. 通过目录项记录页确定用户记录真实所在的页。

 在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。

 3. 在真实存储用户记录的页中定位到具体的记录。


 ③ 迭代 3 次：目录项记录页的目录页
![img_2.png](b加树例子.png)
 如图，我们生成了一个存储更高级目录项的页 33 ，这个页中的两条记录分别代表页 30 和页 32 ，如果用

 户记录的主键值在[1, 320)之间，则到页 30 中查找更详细的目录项记录，如果主键值不小于 320 的

 话，就到页 32 中查找更详细的目录项记录。

 我们可以用下边这个图来描述它：
![img_2.png](b加树.png)
 这个数据结构，它的名称是B+树。

**④ B+Tree**

不论是存放`用户记录`的数据页，还是存放`目录项记录`的数据页，我们都把它们存放到B+树这个数据结构中了，所
以我们也称这些数据页为`节点`。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这
些节点也被称为`叶子节点`，其余用来存放`目录项`的节点称为`非叶子节点`或者`内节点`，其中B+树最上边的那个节
点也称为`根节点`。

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，
之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放 3 条记录，存放目录项
记录的页最多存放 4 条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录
的叶子节点代表的数据页可以存放 100 条用户记录，所有存放目录项记录的内节点代表的数据页可以存
放 1000 条目录项记录，那么：

如果B+树只有 1 层，也就是只有 1 个用于存放用户记录的节点，最多能存放 100 条记录。
如果B+树有 2 层，最多能存放1000×100=10,0000条记录。
如果B+树有 3 层，最多能存放1000×1000×100=1,0000,0000条记录。
如果B+树有 4 层，最多能存放 1000×1000×1000×100 =1000,0000,0000条记录。相当多的记录！！！

 你的表里能存放 100000000000 条记录吗？所以一般情况下，我们用到的B+树都不会超过 4 层，那我们

 通过主键值去查找某条记录最多只需要做 4 个页面内的查找（查找 3 个目录项页和一个用户记录页），又

因为在每个页面内有所谓的Page Directory（页目录），所以在页面内也可以通过二分法实现快速
定位记录。

### 3. 3 常见索引概念

 **索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引**。我们也把非聚集索引称为二级索引或者辅助索引。

#### 1. 聚簇索引
`聚簇索引`并不是一种单独的索引类型，而是一种`数据存储方式`（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。

术语"聚簇"表示**数据行和相邻的键值聚簇的存储**在一起。

#####  聚簇索引特点：
 1. **使用记录主键值的大小进行记录和页的排序**，这包括三个方面的含义：

    - `页内`的记录是按照主键的大小顺序排成一个单向链表。
    - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个`双向链表`。
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键
    - 大小顺序排成一个双向链表。

 2. B+树的`叶子节点`存储的是完整的用户记录。

 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。
 我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。
 这种聚簇索引并不需要我们在MySQLi语句中显式的使用INDEX语句去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。

##### 聚簇索引优点：

 - **数据访问更快**，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快

 - 聚簇索引对于主键的排`序查找`和`范围查找`速度非常快

 - 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以`节省了大量的io操作`。

** 缺点：**

 - **插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。
   因此，对于InnoDB表，我们一般都会定义一个 **自增的ID列为主键**
 - **更新主键的代价很高**，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义 **主键为不可更新**
 - **二级索引访问需要两次索引查找**，第一次找到主键值，第二次根据主键值找到行数据

##### 限制：
- 对于MySQL数据库目前只有InnoDB数据引擎支持聚簇索引l,而MyISAM并坏支持聚簇索引。
- 由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键。
- 如果没有定义主键，Innodb会选择**非空的唯一索引**代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。
- 为了充分利用聚簇索引的聚簇的特性，所以innodb表的**主键列尽量选用有序的顺序id**,而不建议用无序的id, 比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。

#### 2. 二级索引（辅助索引、非聚簇索引）
上边介绍的**聚簇索引只能在搜索条件是主键值时才能发挥作用**，因为B+树中的数据都是按照主键进行排序的。
那如果我们想以别的列作为搜索条件该怎么办呢？肯定不能是从头到尾沿着链表依次遍历记录一遍。
答案：我们可以**多建几棵B+树**，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，
再建一棵B+树，效果如下图所示：

![img_2.png](img_2.png)
##### 什么是回表

**概念：回表** 我们根据这个以c2 列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c 2 列的值
查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表。也就是根据c 2 列的值
查询一条完整的用户记录需要使用到 2 棵B+树！

**问题：** 为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不OK吗？
**回答：**
如果把完整的用户记录放到叶子节点是可以不用回表。但是**太占地方了**，相当于每建立一棵B+树都需要把所有的
用户记录再都拷贝一遍，这就有点太浪费存储空间了。

因为这种按照`非主键列`建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二`级
索引`(英文名`secondary index`),或者`辅助索引`。由于我们使用的是c2列的大小作为B+树的排序规侧，
所以我们也称这个B+树是为c2列建立的索引。

##### 小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：
1. 聚簇索引的`叶子节点`存储的就是我们的`数据记录`，非聚簇索引的叶子节点存储的是`数据位置`。非聚簇索引不会影响数据表的物理存储顺序。
2. **一个表只能有一个`聚簇索引`**，因为只能有一种排序存储的方式，但**可以有多个非聚簇索引**，也就是多个索引目录提供数据检索。
3. 使用聚簇索引的时候，**数据的查询效率高**，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。

```
索引 / 存储引擎 MyISAM InnoDB Memory
```
```
B-Tree索引 支持 支持 支持
```
#### 3. 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，**比方说我们想让B+树按照c2和c3列的大小进行排序**，
这个包含两层含义：

- 先把各个记录和页按照c2列进行排序。
- 在记录的c2列相同的情况下，采用c3列进行排序

注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意
思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

![img_3.png](img_3.png)

- 每条**目录项记录**都由`c2、c3、页号`这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。
- B+树`叶子节点`处的用户记录由c2、c3和主键c1列组成。

建立联合索引只会建立如上图一样的 1 棵B+树。
为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立 2 棵B+树。

### 3. 4 InnoDB的B+树索引的注意事项

#### 1. 根页面位置万年不动

#### 2. 内节点中目录项记录的唯一性

#### 3. 一个页面最少存储 2 条记录()()

## 4. MyISAM中的索引方案

 B树索引适用存储引擎如表所示：

即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索
引是Btree索引；而Memory默认的索引是Hash索引。

MyISAM引擎使用B+Tree作为索引结构，叶子节点的data域存放的是数据记录的地址。

### 4. 2 MyISAM索引的原理

下图是MyISAM索引的原理图。


如果我们在Col 2 上建立一个二级索引，则此索引的结构如下图所示：


### 4. 3 MyISAM 与 InnoDB对比

**MyISAM的索引方式都是“非聚簇”的，与InnoDB包含 1 个聚簇索引是不同的。小结两种引擎中索引的区
别：**

① 在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在
MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。

② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的，索引文件仅保存数
据记录的地址。

③ InnoDB的非聚簇索引data域存储相应记录主键的值，而MyISAM索引记录的是地址。换句话说，
InnoDB的所有非聚簇索引都引用主键作为data域。

④ MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通
过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。

⑤ InnoDB要求表必须有主键（MyISAM可以没有）。如果没有显式指定，则MySQL系统会自动选择一个
可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐
含字段作为主键，这个字段长度为 6 个字节，类型为长整型。

## 5. 索引的代价

 索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：

 空间上的代价

 每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会

 占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。

 时间上的代价


 每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每

 层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还

 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序

 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需

 要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。如果

 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

## 6. MySQL数据结构选择的合理性

### 6. 1 全表遍历

 这里都懒得说了。

### 6. 2 Hash结构

上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做碰撞，在数据库中一般采用链
接法来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：


实验：体会数组和hash表的查找方面的效率区别

**Hash结构效率高，那为什么索引结构要设计成树型呢？**

```
// 算法复杂度为 O(n)
@Test
public void test1(){
int[] arr = new int[ 100000 ];
for(int i = 0 ;i < arr.length;i++){
arr[i] = i + 1 ;
}
```
```
long start = System.currentTimeMillis();
for(int j = 1 ; j<= 100000 ;j++){
int temp = j;
```
```
for(int i = 0 ;i < arr.length;i++){
if(temp == arr[i]){
break;
}
}
}
long end = System.currentTimeMillis();
System.out.println("time： " + (end - start));  //time： 823
```
```
}
```
```
//算法复杂度为 O(1)
@Test
public void test2(){
HashSet<Integer> set = new HashSet<>( 100000 );
for(int i = 0 ;i < 100000 ;i++){
set.add(i + 1 );
}
```
```
long start = System.currentTimeMillis();
```
```
for(int j = 1 ; j<= 100000 ;j++) {
int temp = j;
boolean contains = set.contains(temp);
}
long end = System.currentTimeMillis();
System.out.println("time： " + (end - start));  //time： 5
```
```
}
```

```
索引 / 存储引擎 MyISAM InnoDB Memory
```
```
HASH索引 不支持 不支持 支持
```
**Hash索引适用存储引擎如表所示：**

**Hash索引的适用性：**

采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时
候，通过自适应 Hash 索引可以明显提高数据的检索效率。

我们可以通过innodb_adaptive_hash_index变量来查看是否开启了自适应 Hash，比如：

```
mysql> show variables like '%adaptive_hash_index';
```

### 6. 3 二叉搜索树

 如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。

 1. 二叉搜索树的特点

 2. 查找规则

 创造出来的二分搜索树如下图所示：

 为了提高查询效率，就需要减少磁盘IO数。为了减少磁盘IO的次数，就需要尽量降低树的高度，需要把

 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。


### 6.4 AVL树

 针对同样的数据，如果我们把二叉树改成 M 叉树（M>2）呢？当 M=3 时，同样的 31 个节点可以由下面

 的三叉树来进行存储：

### 6.5 B-Tree

 B 树的结构如下图所示：

 一个 M 阶的 B 树（M>2）有以下的特性：

 1. 根节点的儿子数的范围是 [2,M]。

```
2. 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为
[ceil(M/2), M]。
3. 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。
4. 假设中间节点节点的关键字为：Key[1], Key[2], ..., Key[k-1]，且关键字按照升序排序，即 Key[i]
<Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], ...,
```

```
P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]
指向关键字大于 Key[k-1] 的子树。
5. 所有叶子节点位于同一层。
```
上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2 ，里面的关键字为（ 8 ， 12 ），它
有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8 ，(9，10) 在 8 和 12 之间，而 (13，15)
大于 12 ，刚好符合刚才我们给出的特征。

然后我们来看下如何用 B 树进行查找。假设我们想要查找的关键字是 9 ，那么步骤可以分为以下几步：

```
1. 我们与根节点的关键字 (17， 35 ）进行比较， 9 小于 17 那么得到指针 P1；
2. 按照指针 P1 找到磁盘块 2 ，关键字为（ 8 ， 12 ），因为 9 在 8 和 12 之间，所以我们得到指针 P2；
3. 按照指针 P2 找到磁盘块 6 ，关键字为（ 9 ， 10 ），然后我们找到了关键字 9 。
```
你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比
较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行
比较所需要的时间要多，是数据查找用时的重要因素。B 树相比于平衡二叉树来说磁盘 I/O 操作要少，
在数据查询中比平衡二叉树效率要高。所以只要树的高度足够低，IO次数足够少，就可以提高查询性能。

**再举例 1 ：**

### 6.6 B+Tree

```
MySQL官网说明：
```
 B+ 树和 B 树的差异：

```
1. 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数
+1。
```

```
索引 / 存储引擎 MyISAM InnoDB Memory
```
```
R-Tree索引 支持 支持 不支持
```
 2. 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最

 小）。

 3. 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，非

 叶子节点既保存索引，也保存数据记录。

 4. 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大

 小从小到大顺序链接。

```
B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。
```
```
但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。
```
**思考题：为了减少IO，索引树会一次性加载吗？**

**思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO**

**思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？**

**思考题：Hash 索引与 B+ 树索引的区别**

**思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？**

### 6. 7 R树

R-Tree在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有myisam、bdb、
innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找 20 英里以内所有的餐厅。如果
没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记
录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满
足要求。如果一个地区有 100 家餐厅的话，我们就要进行 100 次位置计算操作了，如果应用到谷歌、百度
地图这种超大数据库中，这种方法便必定不可行了。R树就很好的解决了这种高维空间搜索问题。它把B
树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解
结点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。相对于B-Tree，R-Tree
的优势在于范围查找。

### 附录：算法的时间复杂度

 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在

 于选择合适算法和改进算法。



