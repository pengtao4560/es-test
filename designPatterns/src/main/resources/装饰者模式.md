## 装饰者模式 Decorator

动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)

装饰者模式原理

      1 装饰者模式就像打包一个快递
      主体:比如:陶瓷、衣服(Component)//被装饰者
      包装:比如:报纸填充、塑料泡沫、纸板、木板(Decorator)
      2. ConcreteComponent和Decorator
      ConcreteComponent:具体的主体，比如下面案例的各个单品咖啡
      Decorator:装饰者，比如各调料
      3 在如图的Component与ConcreteComponent之间，如果ConcreteComponent类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。  

装饰者模式原理图：

![](图片/装饰者模式原理图.png)


#### 案例：星巴克咖啡订单项目(咖啡馆) :

    1)咖啡种类/单品咖啡: Espresso(意 大利浓咖啡)、ShortBlack、 LongBlack(美式咖啡)、Decaf(无因咖啡)
    2)调料: Milk、 Soy(豆浆)、 Chocolate
    3)要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
    4)使用0O的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。

解决方案一：

![](图片/装饰者模式案例-使用设计模式之前.png)

方案1-解决星巴克咖啡订单问题分析

    1. Drink是一个抽象类，表示饮料
    2. des就是对咖啡的描述，比如咖啡的名字
    3. cost() 方法就是计算费用，Drink类中做成一个抽象方法.
    4. Decaf就是单品咖啡，继承Drink,并实现cost
    5. Espress&&Milk就是单品咖啡+调料，这个组合很多
    6. 问题:这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料类的数量就会倍增，就会出现类爆炸

方案2-解决星巴克咖啡订单问题分析

![](图片/装饰者模式-解决咖啡订单问题.png)



##### 方案2-解决星巴克咖啡订单问题分析方案2-的问题分析

    1)方案2可以控制类的数量，不至于造成很多的类
    2)在增加或者删除调料种类时，代码的维护量很大
    3)考虑到用户可以添加多份调料时，可以将hasMilk返回一个对应int
    4)考虑使用装饰者模式

#### 装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)

![](图片/装饰者模式-咖啡案例设计方案.png)

说明

    1) Drink 类就是前面说的抽象类，Component
    2) ShortBlack 就单品咖啡
    3) Decorator 是一个装饰类，含有一个被装饰的对象(Drink obj)
    4) Decorator 的 cost 方法进行一个费用的叠加计算，递归的计算价格

    LongBlack直译为【长黑】，国内也称为【澳黑】（澳式黑咖啡）
    ShortBlack 美式咖啡
    Espresso 意大利咖啡
