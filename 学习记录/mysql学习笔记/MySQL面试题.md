#1 数据库的三范式是什么
~~范式是英国人 E.F.Codd（关系数据库的老祖宗）在上个世纪70年代提出关系数据库模型后总结出来的，~~
范式英文名称是 Normal Form，缩写为NF，它是关系数据库理论的基础，也是在设计数据库结构过程中所要遵循的规则和指导方法
**第一范式**：列不可再分
**第二范式**：行可以唯一区分（主键约束）， 也就是说每一条表记录都可以通过主键查找到。
        一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
**第三范式**：表的非主属性不能依赖于其他表的非主属性（外键约束）
三大范式是一级一级依赖的，第二范式是建立在第一范式上的，第三范式是建立在第一第二范式上的

#2. MySQL 数据库引擎有哪些
**可以通过 show engines; 命令查看 mysql 提供的所有存储引擎
其中InnoDB 支持事务、行级锁定、外键和表加密(Supports transactions, row-level locking, foreign keys and encryption for tables)
MYISAM 全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，数据占用空间小**

MariaDB [(none)]> show engines
-> ;
+--------------------+---------+----------------------------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                                          | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------------------------+--------------+------+------------+
| CSV                | YES     | Stores tables as CSV files                                                       | NO           | NO   | NO         |
| MRG_MyISAM         | YES     | Collection of identical MyISAM tables                                            | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables                        | NO           | NO   | NO         |
| MyISAM             | YES     | Non-transactional engine with good performance and small data footprint          | NO           | NO   | NO         |
| SEQUENCE           | YES     | Generated tables filled with sequential values                                   | YES          | NO   | YES        |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, foreign keys and encryption for tables | YES          | YES  | YES        |
| Aria               | YES     | Crash-safe tables with MyISAM heritage                                           | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                                               | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------------------------+--------------+------+------------+
8 rows in set (0.001 sec)

mysql常用引擎包括：MYISAM、InnoDB、Memory、MRG_MyISAM
MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间
相对较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎
InnoDB:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持
外键约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些

~~Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在
mysql重启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于
那些内容变化不频繁的代码表
MRG_MyISAM：是一组MYISAM表的组合~~

#3.说说InnoDB与MyISAM的区别

1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，
   所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；

3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。
   但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该
   过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，
   索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用
   一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

5. InnoDB 不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；

# 4.数据库的事务

什么是事务？ 多条sql语句，要么全部执行成功，要么全部失败

**数据库事务特性**：原子性(Atomic)、一致性(Consistency)、隔离性(Isolation)、持久性
(Durabiliy)。简称ACID。

原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个事务才会提交。
任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。

一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。
如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的。

隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰

持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。

#5.索引是什么
索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引 就像 是一本书前面的目录，能加快数据库的查询速度。
一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，
也可能和数据一起存储在数据文件中）。
我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是
使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引。

# 6.SQL 优化手段有哪些
1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：    
select id from t where num is null    
可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：    
select id from t where num=0

3.应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，
可以使用union all替代 or 

5.in 和 not in 也要慎用，否则会导致全表扫描，    
对于连续的数值，能用 between 就不要用 in 了：    

6.like 查询 以%开头也将导致全表扫描：select id from t where name like '%abc%'

7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。    

8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。   
 

9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，
否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。

11.不要写一些没有意义的查询，如需要生成一个空表结构：    
select col1,col2 into #t from t where 1=0    
这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：    

12.很多时候用 exists 代替 in 是一个好的选择。    

13.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，
SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。

14.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，    
因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。    
一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。

15.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。    
这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

16.尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，    
其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

17.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。

18.避免频繁创建和删除临时表，以减少系统表资源的消耗。

19.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。

20.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，    
以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

21.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

22.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

23.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

24.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。
在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。

25.尽量避免大事务操作，提高系统并发能力。

26.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。


# 7.简单说一说 drop、delete、trunate的区别

##一、从执行速度上来说 drop > truncate >> DELETE

## 二、从原理上讲
总结：
delete属于 数据库DML 操作语言，走事务，只删数据不删表。
InnoDB 不会立即释放磁盘空间，MyISAM 会立刻释放磁盘空间，再插入的数据可以覆盖删除的数据占用的空间
delete是一行一行删除，生成的日志也会占磁盘空间。 执行时会触发 trigger

truncate 属于 数据库据库DDL定义语言，不走事务，原数据不放到 回滚段 rollback segment 中，操作不触发 trigger
立即释放磁盘空间，重置自增序列

drop：属于数据库DDL定义语言，同Truncate；
执行后立即生效，无法找回

2、drop table table_name 立刻释放磁盘空间
drop 语句将删除表的结构被依赖的约束(constrain)、 触发器(trigger)、索引(index)
**可以这么理解，一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了**
具体参考：
[delete、truncate、drop的区别有哪些，该如何选择](https://blog.csdn.net/qq_39390545/article/details/107144859)

### 1、delete
1、DELETE属于数据库DML操作语言，只删除数据不删除表的结构，会走事务，执行时会触发 trigger；

2、在 InnoDB 中，DELETE其实并不会真的把数据删除，mysql 实际上只是给删除的数据打了个标记为已删除，
因此 delete 删除表中的数据时，表文件在磁盘上所占空间不会变小，存储空间不会被释放，只是把删除的数据行设置为不可见。
虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以重用（也就是覆盖）这部分空间。

3、DELETE执行时，会先将所删除数据缓存到rollback segement中，事务commit之后生效;

4、delete from table_name删除表的全部数据,对于MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间;

5、对于带where条件的delete(delete from table_name where xxx), 不管是InnoDB还是MyISAM都不会释放磁盘空间;

6、delete操作以后使用 optimize table table_name 会立刻释放磁盘空间。不管是InnoDB还是MyISAM 。
所以要想达到释放磁盘空间的目的，delete以后执行optimize table 操作。

    示例：查看表占用硬盘空间大小的SQL语句如下：（用M做展示单位，数据库名：csjdemo，表名：demo2）
    select concat(round(sum(DATA_LENGTH/1024/1024),2),'M') as table_size
    from information_schema.tables
    where table_schema='csjdemo' AND table_name='demo2';

    然后执行空间优化语句，以及执行后的表Size变化：

    optimize table demo2

    再看看这张表的大小，就只剩下表结构size了。

7、delete 操作是一行一行执行删除的，并且同时将该行的的删除操作日志记录在redo和undo表空间中以便进行回滚（rollback）
和重做操作，生成的大量日志也会占用磁盘空间。

### 2、truncate
Truncate table TABLE_NAME
1、truncate：属于数据库DDL定义语言，不走事务，原数据不放到 回滚段 rollback segment 中，操作不触发 trigger。
执行后立即生效，无法找回

2、truncate table table_name 立刻释放磁盘空间 ，不管是 InnoDB和MyISAM 。truncate table其实有点类似于drop table 然后create,
只不过这个create table 的过程做了优化，比如表结构文件之前已经有了等等。所以速度上应该是接近drop table的速度;

3、truncate能够快速清空一个表。并且重置自增序列 auto_increment 的值。

但对于不同的类型存储引擎需要注意的地方是：

对于MyISAM，truncate会重置auto_increment（自增序列）的值为1。而delete后表仍然保持auto_increment。
对于InnoDB，truncate会重置auto_increment的值为1。delete后表仍然保持auto_increment。但是在做delete整个表之后
重启MySQL的话，则重启后的auto_increment会被置为1。
也就是说，InnoDB的表本身是无法持久保存auto_increment。delete表之后auto_increment仍然保存在内存，但是重启后就丢失了，
只能从1开始。实质上重启后的auto_increment会从 SELECT 1+MAX(ai_col) FROM t 开始。

4、小心使用 truncate，尤其没有备份的时候，如果误删除线上的表，记得及时~~联系中国民航，订票电话：400-806-9553~~跑路

### 3、drop
Drop table Tablename
1、drop：属于数据库DDL定义语言，同Truncate；
执行后立即生效，无法找回

2、drop table table_name 立刻释放磁盘空间 ，不管是 InnoDB 和 MyISAM; drop 语句将删除表的结构被依赖的约束(constrain)、
触发器(trigger)、索引(index);  依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。

3、小心使用 drop 如果误删除线上的表，记得及时~~联系中国民航，订票电话：400-806-9553~~跑路

**可以这么理解，一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了**

版权声明：本文为CSDN博主「_陈哈哈」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
[原文链接](https://blog.csdn.net/qq_39390545/article/details/107144859)


#8、什么是视图
视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是
有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，
相比多表查询。
#9、 什么是内联接、左外联接、右外联接？

内联接（Inner Join）：匹配2张表中相关联的记录。
左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记
录，右表中未匹配到的字段用NULL表示。
右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记
录，左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join
的左右位置关系。

#10、并发事务带来哪些问题?

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。
并发虽然是必须的，但可能会导致以下的问题。

**脏读**（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，
然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

**丢失修改**（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，
第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，
事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

**不可重复读**（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。
那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。
这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

**幻读**（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。
在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复读和幻读区别：

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增
或者删除比如多次读取一条记录发现记录增多或减少了。

隔离级别            脏读 不可重复读   幻影读
READ-UNCOMMITTED    √   √            √
READ-COMMITTED      ×   √            √
REPEATABLE-READ     ×   ×            √
SERIALIZABLE        ×   ×            ×

#11，事务隔离级别有哪些?MySQL的默认隔离级别是?

SQL 标准定义了四个隔离级别：
READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，
也就是说，该级别可以防止脏读、不可重复读以及幻读。

