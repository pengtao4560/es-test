Redis篇 
# 1，为什么要用缓存
使用缓存的目的就是提升读写性能。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，带来更高的并发量。 
Redis 的读写性能比 Mysql 好的多，我们就可以把 Mysql 中的热点数据缓存到 Redis 中，提升读取性能，同时也减轻了 Mysql 的读取压力。

# 2，使用 Redis 有哪些好处？

1) 读取速度快，因为数据存在内存中，所以数据获取快；
2) 支持多种数据结构，包括字符串、列表、集合、有序集合、哈希等；
3) 支持事务，且操作遵守原子性，即对数据的操作要么都执行，要么都不支持；
4) 还拥有其他丰富的功能，队列、主从复制、集群、数据持久化等功能。

# 3， 什么是 Redis？
Redis 是一个开源（BSD 许可）、基于内存、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。
它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，
除此之外还支持 bitmaps、hyperloglogs 和地理空间（geospatial ）索引半径查询等功能。
它内置了~~复制（Replication）、LUA 脚本（Lua scripting）、LRU 驱动事件（LRU eviction）、~~ 事务（Transactions）和
不同级别的磁盘持久化（persistence）功能，并通过 Redis 哨兵（哨兵）和集群（Cluster）保证缓存的高可用性（High availability）。

# 4， 为什么 使用 Redis 而不是用 Memcache 呢？ 支持数据类型不同/是否支持持久化/key和value内存空间/缓存时间/应用场景/redis支持主从复制
1，支持的数据类型不同

memcache支持string类型，图片，视频等缓存；

redis不仅支持简单的k/v类型，还提供list，hash，set，zset等数据类型。

2，是否支持持久化

memcache不支持持久化，数据都是在内存中，一旦停电则会造成数据丢失，且不可以恢复；

redis支持持久化，通过RDB/AOF两种方式来将数据持久化到磁盘，若停电还可以恢复数据。

3，内存空间和key数量

memcache的key最长250个字符，value不能超过1MB（可以通过配置文件修改）；

redis的key和valve均不能超过512MB。

4，缓存时间

memcache默认支持最多缓存30天；

redis缓存时间没有限制。

5，应用场景不同

redis不仅用做数据缓存，还可以用来消息队列，数据堆栈等方面；

memcache适合简单数据类型，热点常用数据。

6，redis支持主从复制

# 5，为什么 Redis 单线程模型效率也能那么高？
1. C语言实现，效率高
2. 纯内存操作
3. 基于非阻塞的IO复用模型机制
4. 单线程的话就能避免多线程的频繁上下文切换问题
5. 丰富的数据结构（全称采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如亚
   索表，跳表等）
# 6，说说 Redis 的线程模型
~~这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的IO复用模型。如果这个问题回答不上来，就相当于前面的回答是给自己挖坑，因为你答不上来，
面试官对你的印象可能就要打点折扣了。~~

Redis 内部使用文件事件处理器 file event handler ，这个文件事件处理器是单线程的，所以Redis 才叫做单线程的模型。
它采用 IO 多路复用机制同时监听多个 socket ，根据 socket 上的事件来选择对应的事件处理器进行处理。
文件事件处理器的结构包含 4 个部分：
1. 多个 socket 。 
2. IO 多路复用程序。
3. 文件事件分派器。
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，
事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

来看客户端与 Redis 的一次通信过程：
   下面来大致说一下这个图：
1. 客户端 Socket01 向 Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个
   AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列
   中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个
   能与客户端通信的 Socket01，并将该 Socket01 的 AE_READABLE 事件与命令请求处理器关
   联。
2. 假设此时客户端发送了一个 set key value 请求，此时 Redis 中的 Socket01 会产生
   AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事
   件，由于前面 Socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器
   将事件交给命令请求处理器来处理。命令请求处理器读取 Socket01 的 set key value 并在自己
   内存中完成 set key value 的设置。操作完成后，它会将 Socket01 的 AE_WRITABLE 事件与令
   回复处理器关联。
3. 如果此时客户端准备好接收返回结果了，那么 Redis 中的 Socket01 会产生一个
   AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复
   处理器对 Socket01 输入本次操作的一个结果，比如 ok ，之后解除 Socket01 的
   AE_WRITABLE 事件与命令回复处理器的关联。
   这样便完成了一次通信。 不要怕这段文字，结合图看，一遍不行两遍，实在不行可以网上查点资料
   结合着看，一定要搞清楚，否则前面吹的牛逼就白费了。

# 7，为什么 Redis 需要把所有数据放到内存中？
Redis 将数据放在内存中有一个好处，那就是可以实现最快的对数据读取，如果数据存储在硬盘中，磁盘 I/O 会严重影响 Redis 的性能。
而且 Redis 还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。其次现在硬件越来越便宜的情况下，
Redis 的使用也被应用得越来越多使得它拥有很大的优势。

# 8，Redis 的同步机制了解是什么？
Redis 支持主从同步、从从同步。如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将后续修改操作记录到内存的缓冲区，
等 RDB 文件全部同步到复制节点，复制节点接受完成后将RDB 镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，
即可完成同步过程。

# 9， pipeline 有什么好处，为什么要用 pipeline？

使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系。
用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，
那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。

# 10，说一下 Redis 有什么优点和缺点
##优点
   **速度快**：因为数据存在内存中，类似于 HashMap ， HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。
   **支持丰富的数据结构**：支持 String ，List，Set，Sorted Set，Hash 五种基础的数据结构。
   **持久化存储**：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉
   **高可用**：内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移。 内置 Redis Cluster ，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。
   **丰富的特性**：Key过期、计数、分布式锁、消息队列等。

##缺点
   由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然Redis 本身有 Key 过期策略，
   但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
   如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis 2.8 版本，已经有部分重同步的功能，
   但是还是有可能有完整重同步的。比如，新上线的备机。
   修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中， Redis不能提供服务。

# 11 Redis 缓存刷新策略有哪些？

#12， Redis 持久化方式有哪些？以及有什么区别？
Redis 提供两种持久化机制 RDB 和 AOF 机制:
RDB 持久化方式
是指用数据集快照的方式半持久化模式)记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，
用这个临时文件替换上次持久化的文件，达到数据恢复。
优点：
只有一个文件 dump.rdb ，方便持久化。
容灾性好，一个文件可以保存到安全的磁盘。
性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能)
相对于数据集大时，比 AOF 的启动效率更高。

缺点：
数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

AOF=Append-only file 持久化方式
是指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储，保存为 AOF 文件。
优点：
（1）数据安全， AOF 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 AOF 文件中一次。
（2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
（3） AOF 机制的 rewrite 模式。 AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall )
缺点：
（1） AOF 文件比 RDB 文件大，且恢复速度慢。
（2）数据集大的时候，比 RDB 启动效率低。

# 13，持久化有两种，那应该怎么选择呢？
1. 不要仅仅使用 RDB ，因为那样会导致你丢失很多数据。
2. 也不要仅仅使用 AOF ，因为那样有两个问题，第一，你通过 AOF 做冷备没有 RDB 做冷备的恢复速度更快;
   第二， RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备
   份和恢复机制的 bug 。 
3. Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，
   用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF
   文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。
4. 如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新
   构建数据，因为 AOF 中的数据更加完整。
   14，怎么使用 Redis 实现消息队列？
   一般使用 list 结构作为队列， rpush 生产消息， lpop 消费消息。当 lpop 没有消息的时候，要适当
   sleep 一会再重试。
   面试官可能会问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会
   阻塞住直到消息到来。
   面试官可能还问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N
   的消息队列。
   面试官可能还问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用
   专业的消息队列如 rabbitmq 等。
   面试官可能还问 Redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有
   一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用
   sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用
   zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。
   面试扩散：很多面试官上来就直接这么问： Redis 如何实现延时队列？
   
#15. 说说你对Redis事务的理解
   什么是 Redis 事务？原理是什么？
   Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。它可以保证一次执行多个命令，每
   个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务
   的过程中，不会被其他客户端发送来的命令请求打断。
   它的原理是先将属于一个事务的命令发送给 Redis，然后依次执行这些命令。
   Redis 事务的注意点有哪些？
   需要注意的点有：
   Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；
   Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令
   全部执行完毕才会执行其他客户端的命令。
   Redis 事务为什么不支持回滚？
   Redis 的事务不支持回滚，但是执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层
   面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。这样做的原因是因为回滚
   需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。

# 16，Redis 为什么设计成单线程的？
   多线程处理会涉及到锁，并且多线程处理会涉及到线程切···换而消耗 CPU。采用单线程，避免了不
   必要的上下文切换和竞争条件。其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或
   者网络带宽。
# 17，什么是 bigkey？会存在什么影响？
   bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。
   bigkey 的主要影响有：
   网络阻塞；获取 bigkey 时，传输的数据量比较大，会增加带宽的压力。
   超时阻塞；因为 bigkey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能
   性增加。
   导致内存空间不平衡；一个 bigkey 存储数据量比较大，同一个 key 在同一个节点或服务器中存
   储，会造成一定影响。
   18，熟悉哪些 Redis 集群模式？
6. Redis Sentinel
   体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。
7. Redis Cluster
   Redis 官方提供的集群化方案，体量较大时，选择 Redis Cluster ，通过分片，使用更多内
   存。
8. Twemprox
   Twemprox 是 Twtter 开源的一个 Redis 和 Memcached 代理服务器，主要用于管理 Redis 和
   Memcached 集群，减少与Cache 服务器直接连接的数量。
9. Codis
   Codis 是一个代理中间件，当客户端向 Codis 发送指令时， Codis 负责将指令转发到后面的
   Redis 来执行，并将结果返回给客户端。一个 Codis 实例可以连接多个 Redis 实例，也可以启
   动多个 Codis 实例来支撑，每个 Codis 节点都是对等的，这样可以增加整体的 QPS 需求，还能
   起到容灾功能。
10. 客户端分片
    在 Redis Cluster 还没出现之前使用较多，现在基本很少热你使用了，在业务代码层实现，起
    几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操
    作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，
    数据震荡后的自动脚本恢复，实例的监控，等等。
    19，是否使用过 Redis Cluster 集群，集群的原理是什么？
    使用过 Redis 集群，它的原理是：
    所有的节点相互连接
    集群消息通信通过集群总线通信，集群总线端口大小为客户端服务端口 + 10000（固定值）
    节点与节点之间通过二进制协议进行通信
    客户端和集群节点之间通信和通常一样，通过文本协议进行
    集群节点不会代理查询
    数据按照 Slot 存储分布在多个 Redis 实例上
    集群节点挂掉会自动故障转移
    可以相对平滑扩/缩容节点
    Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对
    key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号
    在 0~16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。
# 20， Redis Cluster 集群方案什么情况下会导致整个集群不可用？

 Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。
 假设集群中有 A、B、C 三个集群节点，
 不存在复制模式下，每个集群的节点包含的哈希槽如下：
 节点 A 包含从 0 到 5500 的哈希槽；
 节点 B 包含从 5501 到 11000 的哈希槽；
 节点 C 包含从 11001 到 16383 的哈希槽；
 这时，如果节点 B 出现故障，整个集群就会出现缺少 5501 到 11000 的哈希槽范围而不可用。

# 21，Redis 集群架构模式有哪几种？
Redis 集群架构是支持单节点单机模式的，也支持一主多从的主从结构，还支持带有哨兵的集群部署模式

# 22，说说 Redis 哈希槽的概念？
Redis 集群并没有使用一致性 hash，而是引入了哈希槽的概念。Redis 集群有 16384（2^14）个哈希槽，
每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分hash 槽。

# 23，Redis 常见性能问题和解决方案有哪些

1) Redis主库 Master 最好不要做任何持久化工作，如 RDB （Redis DataBase）内存快照和 AOF (Append Only File)日志文件；
2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；
3) 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内；
4) 尽量避免在压力很大的主库上增加从库；
5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3….；
  这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。

# 24. 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？ keys命令或 scan命令

1. 使用 keys 命令
   直接使用 keys 命令查询，但是如果是在生产环境下使用会出现一个问题，keys 命令是遍历查询的，查询的时间复杂度为 O(n)，数据量越大查询时间越长。
   而且 Redis 是单线程，keys 指令会导致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，
   直到 keys 执行完毕才能恢复。这在生产环境是不允许的。除此之外，需要注意的是，这个命令没有分页功能，会一次性查询出所有符合条件的 key 值，
   会发现查询结果非常大，输出的信息非常多。所以不推荐使用这个命令。

2. 使用 scan 命令
   scan 命令可以实现和 keys 一样的匹配功能，但是 scan 命令在执行的过程不会阻塞线程，并且查找的数据可能存在重复，需要客户端操作去重。 
   因为 scan 是通过游标方式查询的，所以不会导致Redis 出现假死的问题。Redis 查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，
   则说明遍历还没结束，客户端继续遍历查询。scan 在检索的过程中，被删除的元素是不会被查询出来的，但是如果在迭代过程中有元素被修改， 
   scan 不能保证查询出对应元素。相对来说，scan 指令查找花费的时间会比 keys 指令长。

# 25，如果有大量的 key 需要设置同一时间过期，一般需要注意什么？
如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致数据库崩溃，系统出现 502 问题。
也有可能同时失效，那一刻不用都访问数据库，压力不够大的话，那么 Redis 会出现短暂的卡顿问题。
所以为了预防这种问题的发生，最好给数据的过期时间加一个随机值，让过期时间更加分散。

# 26，什么情况下可能会导致 Redis 阻塞？

Redis 产生阻塞的原因主要有内部和外部两个原因导致：
## 内部原因
如果 Redis 主机的 CPU 负载过高，也会导致系统崩溃；
数据持久化占用资源过多；
对 Redis 的 API 或指令使用不合理，导致 Redis 出现问题。
## 外部原因
外部原因主要是服务器的原因，例如服务器的 CPU 线程在切换过程中竞争过大，内存出现问题、网络问题等。

# 27，缓存和数据库谁先更新呢？
高并发场景下，到底先更新缓存（Redis）还是先更新数据库（MySQL）的问题？
此问题待梳理，有点难
[](https://blog.csdn.net/qq_39033181/article/details/119276120?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6-119276120-blog-103092613.pc_relevant_multi_platform_whitelistv1_exp2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6-119276120-blog-103092613.pc_relevant_multi_platform_whitelistv1_exp2&utm_relevant_index=9)
解决方案
1. 写请求过来，将写请求缓存到缓存队列中，并且开始执行写请求的具体操作（删除缓存中的数据，更新数据库，更新缓存）。
2. 如果在更新数据库过程中，又来了个读请求，将读请求再次存入到缓存队列（可以搞n个队列，采用key的hash值进行队列个数取模hash%n，落到对应的队列中，队列需要保证顺序性）
   中，顺序性保证等待队列前的写请求执行完成，才会执行读请求之前的写请求删除缓存失败，直接返回，此时数据库中的数据是旧值，并且与缓存中的数据是一致的，不会出现缓存一致性
   的问题。
3. 写请求删除缓存成功，则更新数据库，如果更新数据库失败，则直接返回，写请求结束，此时数据库中的值依旧是旧值，读请求过来后，发现缓存中没有数据， 则会直接向数据库中请求，
   同时将数据写入到缓存中，此时也不会出现数据一致性的问题。
4. 更新数据成功之后，再更新缓存，如果此时更新缓存失败，则缓存中没有数据，数据库中是新值 ，写请求结束，此时读请求还是一样，发现缓存中没有数据，同样会从数据库中读取数据，
   并且存入到缓存中，其实这里不管更新缓存成功还是失败， 都不会出现数据一致性的问题。
   上面这方案解决了数据不一致的问题，主要是使用了串行化，每次操作进来必须按照顺序进行。如果某个队列元素积压太多，可以针对读请求进行过滤，提示用户刷新页面，重新请求。

   潜在的问题，留给大家自己去想吧，因为这个问题属于发散性。
   1，请求时间过长，大量的写请求堆压在队列中，一个读请求来得等都写完了才可以获取到数据。
   2，读请求并发高
   3，热点数据路由问题，导致请求倾斜。
